
module SliceSampling

using AbstractMCMC
using Accessors
using Distributions
using FillArrays
using LinearAlgebra
using LogDensityProblems
using SimpleUnPack
using Random

# reexports
using AbstractMCMC: sample, MCMCThreads, MCMCDistributed, MCMCSerial
export sample, MCMCThreads, MCMCDistributed, MCMCSerial

# Interfaces
abstract type AbstractSliceSampling <: AbstractMCMC.AbstractSampler end

"""
    struct Transition

Struct containing the results of the transition.

# Fields
- `params`: Samples generated by the transition.
- `lp::Real`: Log-target density of the samples.
- `info::NamedTuple`: Named tuple containing information about the transition. 
"""
struct Transition{P, L <: Real, I <: NamedTuple}
    "current state of the slice sampling chain"
    params::P

    "log density of the current state"
    lp::L

    "information generated from the sampler"
    info::I
end

"""
    initial_sample(rng, model)

Return the initial sample for the `model` using the random number generator `rng`.

# Arguments
- `rng::Random.AbstractRNG`: Random number generator.
- `model`: the model of interest.
"""
function initial_sample end

function exceeded_max_prop(max_prop::Int)
    error("Exceeded maximum number of proposal $(max_prop).\n", 
          "Here are possible causes:\n",
          "- The model might be broken or pathologic.\n",
          "- There might be a bug in the sampler.")
end

## Univariate Slice Sampling Algorithms
export Slice, SliceSteppingOut, SliceDoublingOut

abstract type AbstractUnivariateSliceSampling <: AbstractSliceSampling  end

function accept_slice_proposal end

function find_interval end

include("univariate.jl")
include("steppingout.jl")
include("doublingout.jl")


## Multivariate slice sampling algorithms
abstract type AbstractMultivariateSliceSampling <: AbstractSliceSampling  end

# Univariate-to-Multivariate Strategies 
export RandPermGibbs, HitAndRun

include("gibbsgeneral.jl")
include("randpermgibbs.jl")
include("hitandrun.jl")

# Latent Slice Sampling 
export LatentSlice
include("latent.jl")

# Gibbsian Polar Slice Sampling 
export GibbsPolarSlice
include("gibbspolar.jl")

# Turing Compatibility

if !isdefined(Base, :get_extension)
    using Requires
end

@static if !isdefined(Base, :get_extension)
    function __init__()
        @require Turing = "fce5fe82-541a-59a6-adf8-730c64b5f9a0" include(
            "../ext/SliceSamplingTuringExt.jl"
        )
    end
end

end
